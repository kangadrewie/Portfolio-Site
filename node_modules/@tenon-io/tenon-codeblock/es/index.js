var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

import React, { Component, createRef } from 'react';
import PropTypes from 'prop-types';
import SyntaxHighlighter, { registerLanguage } from 'react-syntax-highlighter/light';
import SyntaxHighlighterJsx, { registerLanguage as registerLanguageJsx } from 'react-syntax-highlighter/prism-light';
import javascript from 'react-syntax-highlighter/languages/hljs/javascript';
import json from 'react-syntax-highlighter/languages/hljs/json';
import css from 'react-syntax-highlighter/languages/hljs/css';
import xml from 'react-syntax-highlighter/languages/hljs/xml';
import jsx from 'react-syntax-highlighter/languages/prism/jsx';
import { atomDark } from 'react-syntax-highlighter/styles/prism';
import axios from 'axios';
import './a11y-dark.css';

/**
 * @component
 * Code highligher component using react-syntax-highlighter, but tweaked for
 * accessibility.
 *
 * Takes a filename containing the code to show and an optional language setting.
 * If no language setting is given, the component defaults to JSX.
 *
 * It also allows a free text codeString to be given. If both are set, file will
 * override codeString
 *
 * This code block will autoreset any changes to the contenteditable <code>
 * tag and, if the user made any changes before the reset, the onRest
 * handler will be called.
 *
 * @prop {string} file - The path to the file to load.
 * @prop {string} codeString - A string value containing code to display.
 * @prop {string} language - Select a highlighter for jsx | javascript | html | json | css.
 * @prop {function} onReset - A callback function to execute when changes to the
 *          contenteditable section is reverted.
 *  */

var CodeBlock = function (_Component) {
    _inherits(CodeBlock, _Component);

    function CodeBlock() {
        var _temp, _this, _ret;

        _classCallCheck(this, CodeBlock);

        for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
        }

        return _ret = (_temp = (_this = _possibleConstructorReturn(this, _Component.call.apply(_Component, [this].concat(args))), _this), _this.customThemeJsx = atomDark, _this.codeBlockFrame = createRef(), _this.loadedInnerHTMLString = '', _this.state = {
            codeString: ''
        }, _this.onBlurHandler = function () {
            var onReset = _this.props.onReset;


            var oldCodeString = _this.state.codeString;

            if (_this.loadedInnerHTMLString !== _this.codeBlockFrame.current.querySelector('code').innerHTML.toString() && onReset) {
                onReset();
            }

            _this.setState({ codeString: '' }, function () {
                _this.setState({ codeString: oldCodeString });
            });
        }, _this.onFocusHandler = function (e) {
            var range = document.createRange();
            range.selectNodeContents(e.target);
            var selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
        }, _this.setText = function () {
            var _this$props = _this.props,
                file = _this$props.file,
                codeString = _this$props.codeString;


            if (file) {
                axios.get(file).then(function (_ref) {
                    var data = _ref.data;

                    _this.setCodeString(data);
                });
            } else if (codeString) {
                _this.setCodeString(codeString);
            }
        }, _this.setCodeString = function (codeString) {
            _this.setState({ codeString: codeString }, function () {
                _this.loadedInnerHTMLString = _this.codeBlockFrame.current.querySelector('code').innerHTML.toString();
            });
        }, _temp), _possibleConstructorReturn(_this, _ret);
    }

    /**
     * @function
     * Configures react-syntax-highlighter for the supported languages
     * in order to minimise the footprint of the component.
     *
     * Also overrides some colour settings for accessibility.
     *
     * Finally fetches the file from the server.
     */
    CodeBlock.prototype.componentDidMount = function componentDidMount() {
        registerLanguageJsx('jsx', jsx);
        registerLanguage('javascript', javascript);
        registerLanguage('json', json);
        registerLanguage('xml', xml);
        registerLanguage('css', css);

        this.customThemeJsx = _extends({}, atomDark, {
            comment: {
                color: '#FFFFFF'
            },
            number: {
                color: '#FF82FC'
            }
        });

        this.setText();
    };

    /**
     * @function
     * Resets the code text when the filename or codeString changes.
     *
     * @param {object} prevProps
     */


    CodeBlock.prototype.componentDidUpdate = function componentDidUpdate(prevProps) {
        if (prevProps.file !== this.props.file || prevProps.codeString !== this.props.codeString) {
            this.setText();
        }
    };

    /**
     * @function
     * Event handler for onBlur of the <code> tag. Due to the tag
     * being set as contenteditable, the user can accidentally
     * edit the code. This resets the code on blur to ensure a more
     * stable interface;
     *
     * It also checks whether the user had changed the tag content.
     * If so the onReset handler is called.
     *
     * The implementation here is to allow for IE support.
     */


    /**
     * @function
     * Event handler for the onFocus of the <code> tag. With the tag
     * being set to contenteditable, this autoselects the code text
     * on focus.
     *
     * @param {SyntheticEvent} e
     */


    /**
     * @function
     *
     * If a file is given it GETs the file from the server and
     * sets the content to the component state.
     *
     * Alternatively if a codeString is given, it is set to the
     * component state. This is an intentional duplication of
     * the prop into the state so that the mechanism can be
     * re-used without code duplication.
     */


    /**
     * @function
     * Render function. Please note that the following changes to the <code> tag:
     *
     * 1.The tag is made contenteditable to allow better keyboard interaction for
     * keyboard users. Due to this the suppressContentEditableWarning flag must be
     * set for React to avoid console warnings.
     *
     * 2. The tag is given a tabindex of 0 to make it easier to select.
     *
     * 3. Spellcheck is set to false to avoid browsers from spellchecking the
     * code text.
     *
     * @returns {React.Node}
     */
    CodeBlock.prototype.render = function render() {
        var codeString = this.state.codeString;
        var _props = this.props,
            className = _props.className,
            _props$language = _props.language,
            language = _props$language === undefined ? 'jsx' : _props$language;


        return codeString ? React.createElement(
            'div',
            {
                className: className ? className : null,
                ref: this.codeBlockFrame
            },
            language === 'jsx' ? React.createElement(
                SyntaxHighlighterJsx,
                {
                    language: language,
                    style: this.customThemeJsx,
                    codeTagProps: {
                        contentEditable: 'true',
                        suppressContentEditableWarning: 'true',
                        tabIndex: 0,
                        spellCheck: 'false',
                        onBlur: this.onBlurHandler,
                        onFocus: this.onFocusHandler
                    }
                },
                codeString
            ) : React.createElement(
                SyntaxHighlighter,
                {
                    language: language === 'html' ? 'xml' : language,
                    className: 'code-block',
                    useInlineStyles: true,
                    customStyle: {
                        backgroundColor: '#2b2b2b',
                        color: '#f8f8f2',
                        padding: '1em',
                        borderRadius: '0.4em',
                        overflowX: 'auto',
                        lineHeight: '1.7'
                    },
                    codeTagProps: {
                        contentEditable: 'true',
                        suppressContentEditableWarning: 'true',
                        tabIndex: 0,
                        spellCheck: 'false',
                        onBlur: this.onBlurHandler,
                        onFocus: this.onFocusHandler
                    }
                },
                codeString
            )
        ) : null;
    };

    return CodeBlock;
}(Component);

CodeBlock.propTypes = process.env.NODE_ENV !== "production" ? {
    file: PropTypes.string,
    codeString: PropTypes.string,
    language: PropTypes.oneOf(['javascript', 'jsx', 'json', 'html', 'css']),
    onReset: PropTypes.func
} : {};


export default CodeBlock;